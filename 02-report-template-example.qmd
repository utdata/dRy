---
title: "02-report-template-example"
params:
  album: "1989"
echo: true
---

title: title of file.
params: what we're filtering for.
echo: 'true' repeats all code chunks in render file, 'false' excludes them.

## Set up

```{r}

#| label: setup
#| message: false
#| warning: false
#| echo: true

library(tidyverse)
library(janitor)

```


### Importing our files 

```{r}
#| label: import

taylor_files_list <- list.files(
  "data-processed-taylor",
  pattern = ".csv",
  full.names = T
)

taylor_files_list
```

### Combining our files

```{r}
#| label: combine-files 

taylor_songs <- taylor_files_list |> map(
  read_csv,
  col_types = cols(album = col_character())
) |> list_rbind() |> 
  clean_names()

taylor_songs |> glimpse()
```
# Defining paramater(s)

Here we'll create our parameter

```{r}
albums <- str_split_1( #<1>
  params$album, ",") #<2>

albums
```
1. Use str_split_1 to split a single string into pieces to return a single character vector.
2.  We use 'params$album' to create the string that will be read through str_split_1 . In this case, that will be the single parameter '1989'. The comma is used to determine when one value stops and the other begins; this is useful when you are looking for mulitples of one type of parameter.


Album Names: `r params$album` 
Use this to check your work ^


# All 1989 songs

OK, now we can look for all occurrence of '1989' in our data.

```{r}
songs <- taylor_songs |> 
  filter(album %in% albums) #<2>

songs
```

2. Filtering for every instance that album (the column) is equal to albums (the parameter.)

## Let's do some analysis!

Let's look at acousticness first. On Kaggle, where we got the data, the author defines acousticness like this: "A confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic."

```{r}
acousticness <- songs |> arrange(acousticness |> desc()) |> 
  select(
    name, album, acousticness
  )

acousticness
```

Now I want to look at the most danceable songs. Our data author tells us: "Danceability describes how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity. A value of 0.0 is least danceable and 1.0 is most danceable." 

```{r}
danceability <- songs |> arrange(danceability |> desc()) |> 
  select(
    name, album, danceability
  )

danceability
```

What about popularity? It's unclear how popularity is calculated, but it is on a scale from 0 to 100. 

```{r}
popularity <- songs |> arrange(popularity |> desc()) |> 
  select(
    name, album, popularity
  )

popularity
```

Now, I want to look at tempo vs danceability. We already saw the definition of danceability but the tempo is in beats per minute (BPM). Let's make a chart. 

```{r}
ggplot(songs, aes(x = tempo, y = danceability)) +
  geom_point() +
  scale_x_continuous(name = "Tempo (BPM)", n.breaks = 10) +
  scale_y_continuous(name = "Danceability", limits = c(0,1)) +
  labs(title = str_glue("How does the tempo affect danceability of Taylor Swift songs from album(s): {album_names}", album_names = params$album))  
```

Note above, we used our `r params$album` variable so that our chart title will change based on what we input in our render file for which albums. 
